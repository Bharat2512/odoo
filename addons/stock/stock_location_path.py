# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from datetime import datetime
from dateutil import relativedelta

from odoo import models, fields, api
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT


class StockLocationPath(models.Model):
    _name = "stock.location.path"
    _description = "Pushed Flows"
    _order = "name"

    @api.multi
    @api.depends('route_id.sequence')
    def _get_rules(self):
        print "_get_rules >>>>>>>>>>>>>>>>>>>>>>>"
        res = []
        for route in self:
            res += [x.id for x in route.push_ids]
        return res

    name = fields.Char('Operation Name', required=True)
    company_id = fields.Many2one('res.company', 'Company', default=lambda self: self.env.user.company_id)
    route_id = fields.Many2one('stock.location.route', 'Route')
    location_from_id = fields.Many2one('stock.location', 'Source Location', ondelete='cascade', select=1, required=True,
        help="This rule can be applied when a move is confirmed that has this location as destination location")
    location_dest_id = fields.Many2one('stock.location', 'Destination Location', ondelete='cascade', select=1, required=True,
        help="The new location where the goods need to go")
    delay = fields.Integer('Delay (days)', help="Number of days needed to transfer the goods", default=0)
    picking_type_id = fields.Many2one('stock.picking.type', 'Picking Type', required=True,
        help="This is the picking type that will be put on the stock moves")
    auto = fields.Selection([('auto', 'Automatic Move'), ('manual', 'Manual Operation'), ('transparent', 'Automatic No Step Added')], 'Automatic Move', required=True, select=1, default='auto',
        help="The 'Automatic Move' / 'Manual Operation' value will create a stock move after the current one.  " \
             "With 'Automatic No Step Added', the location is replaced in the original move.")
    propagate = fields.Boolean('Propagate cancel and split', default=True, help='If checked, when the previous move is cancelled or split, the move generated by this move will too')
    active = fields.Boolean(default=True)
    warehouse_id = fields.Many2one('stock.warehouse', 'Warehouse')
    route_sequence = fields.Integer(related='route_id.sequence', string='Route Sequence', store=True)
    sequence = fields.Integer()

    @api.model
    def _prepare_push_apply(self, rule, move):
        print "_prepare_push_apply >>>>>>>>>>>>>>>>>>>>>>>", self, rule, move
        newdate = (datetime.strptime(move.date_expected, DEFAULT_SERVER_DATETIME_FORMAT) + relativedelta.relativedelta(days=rule.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
        return {
                'origin': move.origin or move.picking_id.name or "/",
                'location_id': move.location_dest_id.id,
                'location_dest_id': rule.location_dest_id.id,
                'date': newdate,
                'company_id': rule.company_id and rule.company_id.id or False,
                'date_expected': newdate,
                'picking_id': False,
                'picking_type_id': rule.picking_type_id and rule.picking_type_id.id or False,
                'propagate': rule.propagate,
                'push_rule_id': rule.id,
                'warehouse_id': rule.warehouse_id and rule.warehouse_id.id or False,
            }

    @api.model
    def _apply(self, rule, move):
        print "_apply >>>>>>>>>>>>>>>>>>>>>>>", self, rule, move
        newdate = (datetime.strptime(move.date_expected, DEFAULT_SERVER_DATETIME_FORMAT) + relativedelta.relativedelta(days=rule.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
        if rule.auto == 'transparent':
            old_dest_location = move.location_dest_id.id
            move.write({
                'date': newdate,
                'date_expected': newdate,
                'location_dest_id': rule.location_dest_id.id
            })
            #avoid looping if a push rule is not well configured
            if rule.location_dest_id.id != old_dest_location:
                #call again push_apply to see if a next step is defined
                move._push_apply()
        else:
            vals = self._prepare_push_apply(rule, move)
            move_id = move.copy(vals)
            move.write({
                'move_dest_id': move_id.id,
            })
            move_id.action_confirm()
